一、符号与输入/输出维度约定\n- 空间维数 s ∈ ℕ，且 s ≥ 1。\n- 批大小 N ∈ ℕ，输入通道数 C ∈ ℕ，输出通道数 M ∈ ℕ，分组数 G ∈ ℕ，满足 ONNX 约束：C = (W.shape[1] × G)，M mod G = 0。\n- 每个空间轴 i 的输入尺寸 Di ∈ ℕ（i=1,…,s）。\n- 每个空间轴 i 的卷积核尺寸 Ki ∈ ℕ（i=1,…,s）。\n- 每个空间轴 i 的步长 si ∈ ℕ（i=1,…,s），若未给出则 si = 1。\n- 每个空间轴 i 的膨胀（dilation）δi ∈ ℕ（i=1,…,s），若未给出则 δi = 1。\n- 每个空间轴 i 的 padding 分为起始端 pi,beg ∈ ℕ 与末端 pi,end ∈ ℕ（i=1,…,s）。若 auto_pad = NOTSET，则由 pads 显式给出；若 auto_pad = VALID，则 pi,beg = 0 且 pi,end = 0；若 auto_pad ∈ {SAME_UPPER, SAME_LOWER}，则见下述“padding 的确定”。\n- 组内输入通道数 Cg = C / G，组内输出通道数 Mg = M / G。对于任意输出通道 m（0 ≤ m ≤ M−1），其所属的组索引 g = ⌊m / Mg⌋，且该输出通道仅与输入通道区间 {g·Cg, …, (g+1)·Cg − 1} 发生连接。\n- 输出空间尺寸 Oi（i=1,…,s）由以下公式确定（若 auto_pad = NOTSET/VALID，即显式或零 padding）：\n  Oi = ⎣ (Di + pi,beg + pi,end − δi·(Ki − 1) − 1) / si ⎦ + 1\n  若 auto_pad ∈ {SAME_UPPER, SAME_LOWER}，先令期望\n  Oi = ⎡ Di / si ⎤，\n  再令总填充 Pi = max(0, (Oi − 1)·si + δi·(Ki − 1) + 1 − Di)。\n  若 SAME_UPPER: pi,beg = ⎣Pi/2⎦，pi,end = ⎡Pi/2⎤；\n  若 SAME_LOWER: pi,beg = ⎡Pi/2⎤，pi,end = ⎣Pi/2⎦。\n- 输入张量 X 维度：[N, C, D1, …, Ds]。\n- 权重张量 W 维度：[M, Cg, K1, …, Ks]。\n- 可选偏置张量 B 维度：[M]（若存在）。\n- 输出张量 Y 维度：[N, M, O1, …, Os]。\n\n二、为满足 SIMD 框架的输入张量集合 MultiTensorInput\n- 我们构造输入张量集合包含以下张量：\n  1) 数据张量 X，维度 [N, C, D1, …, Ds]。\n  2) 权重张量 W，维度 [M, Cg, K1, …, Ks]。\n  3) 常量零张量 Z，标量张量，维度 []，取值恒为 0。\n  4) 若存在偏置 B，则加入偏置张量 B，维度 [M]。\n- 因此：\n  - 若无偏置：p = 3，依次为 X、W、Z。\n  - 若有偏置：p = 4，依次为 X、W、B、Z。\n- 上述每个张量都可嵌入到框架的 Tensor 类型中。Z 是 0 维张量（Index 长度为 0），取值恒为 0。\n\n三、核函数 θ 的定义（KernelFunction）\n- 首先定义中间计数：\n  - k′ = Cg × (∏i=1..s Ki)。它表示：对某个输出元素，卷积所需的“输入通道×核内空间位置”的成对数量。\n- 然后定义核函数的输入长度 k：\n  - 若无偏置：k = 2·k′。\n  - 若有偏置：k = 2·k′ + 1。\n- 约定核函数输入向量 v 的位置含义（统一顺序）：\n  - 对 t = 0,…,k′−1：v[t] 是对应的“输入值”（来自 X 或 Z）。\n  - 对 t = 0,…,k′−1：v[k′+t] 是对应的“权重值”（来自 W）。\n  - 若有偏置：v[2·k′] 是对应的偏置值（来自 B）。\n- 定义核函数 θ: ℝ^k → ℝ 为\n  - 若无偏置：θ(v) = Σ_{t=0}^{k′−1} v[t] · v[k′+t]。\n  - 若有偏置：θ(v) = (Σ_{t=0}^{k′−1} v[t] · v[k′+t]) + v[2·k′]。\n- 该核函数是简单的逐项乘加（点积）以及可选的加偏置。\n\n四、输出索引与“邻域”展开顺序\n- 输出索引写作 (n, m, o1, …, os)，其中\n  - 0 ≤ n < N，0 ≤ m < M，\n  - 0 ≤ oi < Oi 对每个 i=1,…,s。\n- 对该输出索引，我们需要遍历组内输入通道与核空间位置：\n  - 组索引 g = ⌊m / Mg⌋。\n  - 组内输入通道 q ∈ {0,…,Cg−1}。\n  - 核空间坐标 r = (r1,…,rs)，其中 ri ∈ {0,…,Ki−1}。\n- 我们对 (q, r1,…,rs) 采用字典序线性化生成 t ∈ {0,…,k′−1}，具体线性化函数\n  lin(q, r1,…,rs) = q·(∏i Ki) + Σ_{i=1..s} [ri · (∏_{j=1..i−1} Kj)]，\n  其中空积约定为 1。如此 t 唯一覆盖所有 Cg × ∏i Ki 个组合。\n- t 的逆映射按同样的进制分解即可恢复 (q, r1,…,rs)。\n\n五、映射函数 map（GeneralizedDependencyMapping.map）的逐步构造\n- 固定一个输出索引 (n, m, o1,…,os)。\n- 计算该输出位置对应的输入“卷积窗口”的左上（或“起点”）基址：\n  - 对每个 i=1,…,s，定义基址 bi = oi·si − pi,beg。\n- 对每个 t = lin(q, r1,…,rs)（q 与 r 来自四节）：\n  1) 计算当前核位置对应的输入坐标：\n     - 输入通道 c = g·Cg + q。该 c 一定满足 0 ≤ c < C。\n     - 空间坐标 xi = bi + ri·δi（对每个 i=1,…,s）。\n  2) 判断空间坐标是否在边界内：\n     - in_bounds = ∧_{i=1..s} (0 ≤ xi < Di)。\n  3) 选择第 t 个“输入值”指针：\n     - 若 in_bounds 为真，则第 t 个“输入值”指针为 X[n, c, x1,…,xs]；\n     - 否则为 Z[]（零张量的唯一索引）。\n  4) 选择第 t 个“权重值”指针：\n     - 始终为 W[m, q, r1,…,rs]（权重索引总是有效）。\n- 依上述顺序，我们得到长度为 2·k′ 的输入指针序列：\n  - 先依照 t 从 0 到 k′−1 收集 k′ 个“输入值”指针（X 或 Z）；\n  - 再依照 t 从 0 到 k′−1 收集 k′ 个“权重值”指针（W）。\n- 若存在偏置张量 B，则再附加 1 个指针：\n  - 偏置指针为 B[m]。\n- 因而 map(n,m,o1,…,os) 返回一个长度为 k 的 List.Vector(InputPointer)，其中 k = 2·k′(+1 若有 B)。\n- 有效性检验：\n  - 当 in_bounds 为真时，X 的索引 (n,c,x1,…,xs) 满足 0≤n<N，0≤c<C，且 0≤xi<Di，因此是有效指针；\n  - 当 in_bounds 为假时，改为使用 Z[]，其索引总是有效；\n  - W[m,q,r1,…,rs] 总是有效，因为 0≤m<M，0≤q<Cg，0≤ri<Ki；\n  - 若有偏置，B[m] 也总是有效，因为 0≤m<M。\n  因此 GeneralizedDependencyMapping.valid 条件成立。\n\n六、SIMD 核函数输入序的数值读数与输出的形成\n- 令 map 产出的 k 个指针依次取值形成 v ∈ ℝ^k。\n- 定义 x_t = v[t]（t=0,…,k′−1），w_t = v[k′+t]（t=0,…,k′−1）。若有偏置，b = v[2·k′]，否则 b = 0。\n- 核函数输出为 y = Σ_{t=0}^{k′−1} x_t · w_t + b。\n- 这与常规分组卷积在该输出位置 (n,m,o1,…,os) 的计算完全一致：\n  - 乘法操作逐项对应输入补零后的感受野与权重的位置对；\n  - 求和对应卷积求和；\n  - b 对应偏置项；\n  - 越界位置通过使用 Z[] 实现显式零填充，严格避免无效索引。\n\n七、关于 k 的常量性与 SIMD 适配性\n- k′ = Cg × ∏i Ki 对所有输出索引恒定，因此 k = 2·k′ (+1 若有偏置) 为常数，满足 SIMDFunction 对固定 k 的要求。\n- 依上述 map，每个输出元素都从输入张量集合中提取同样数量的标量，且核函数 θ 对这些标量做固定的点积与可选的加偏置操作，符合“SIMD 算子”的形式化定义。\n\n八、小结\n- 该 Conv 算子可编码为给定 Lean4 SIMD 框架中的一个 SIMDFunction：\n  - 输入 MultiTensorInput 为 {X, W, Z} 或 {X, W, B, Z}；\n  - 依第五节给出 GeneralizedDependencyMapping.map；\n  - 依第三节给出核函数 θ。\n- auto_pad、pads、strides、dilations、groups 等全部通过 map 的索引计算与越界时指向 Z 来精确实现，不需要对核函数做任何分支处理。\n\n因此，ONNX Conv 可以转换为 SIMD 算子；核函数与映射函数如上所述。
