可以转换为SIMD算子\n\n以下给出严格、细粒度、逐步的自然语言刻画，包含核函数与映射函数，所有符号均明确定义，并且每一步均为直接推导。\n\n一、基础对象与符号\n- 设输入张量的维度列表为 dims = [d0, d1, ..., d_{n-1}]，其中 n = dims.length，且对每个 i ∈ {0, ..., n-1}，d_i 为正整数。\n- 定义索引类型 Index(n) 为长度为 n 的自然数向量。对 out_idx ∈ Index(n)，称其有效(Valid)当且仅当对所有 i ∈ Fin n，有 out_idx.get(i) < dims.get(i)。\n- 用实数 ℝ 作为元素值的数学刻画（ONNX 的 T ∈ {float16, bfloat16, float, double} 在数学层面可视为嵌入到 ℝ；实际的数据类型回写/舍入不在本SIMD语义内处理）。\n- 定义输入张量 X 为函数 X : Index(n) → ℝ。即 X(idx) 表示 idx 位置的标量。\n- 目标输出张量 Y 的维度与输入相同，为 dims，故 Y : Index(n) → ℝ。\n\n二、多张量输入结构 MultiTensorInput\n- 令 p = 1（只有一个输入张量）。\n- 令 input.dims 为长度为 1 的向量，其唯一元素为 dims。记 dims0 = input.dims.get(0) = dims。\n- 定义 input.tensors(0) = X。\n- 则 input 为一个包含单个张量 X 的 MultiTensorInput。\n\n三、输出维度\n- 令 output_dims = dims（与输入相同）。\n- 因此输出索引类型为 Index(n)，与输入相同。\n\n四、核函数 KernelFunction\n- 令 k = 1（该算子是逐元素一元运算）。\n- 定义核函数 θ: (List.Vector ℝ 1) → ℝ 为\n  θ(v) = asinh(v.get(0))。\n- asinh 的数学定义（为消除歧义并保证精确性）：\n  对任意 x ∈ ℝ，asinh(x) = ln(x + sqrt(x^2 + 1))，\n  其中 ln 为自然对数，sqrt 为非负平方根。该定义对所有实数 x 有效。\n\n五、依赖映射 GeneralizedDependencyMapping\n- 需要定义映射 τ: Index(n) → List.Vector (InputPointer input) 1。\n- 对任意输出索引 out_idx ∈ Index(n)，定义\n  τ(out_idx) = [ptr]，这是长度为 1 的向量，其中\n  - ptr.tensor_idx = 0（唯一的输入张量 X）；\n  - ptr.multi_dim_idx = out_idx（与输出索引逐元素对齐）。\n- 有效性说明：\n  若 out_idx 对 output_dims 有效，即 ∀ i ∈ Fin n, out_idx.get(i) < dims.get(i)，\n  则 ptr.multi_dim_idx = out_idx 对 input.dims.get(0) = dims 也有效。\n  因此 ptr 为有效的输入指针（validInputPointer 成立）。\n\n六、SIMD 计算过程的逐步推导\n- 给定 out_idx ∈ Index(n) 且 validIndex(output_dims, out_idx) 成立：\n  1) 根据依赖映射，取输入指针向量：\n     input_pointers = τ(out_idx) = [ptr]，其中 ptr 如上所述。\n  2) 读取标量输入：\n     input_scalars = map(getValueAtPointer input) input_pointers\n                   = [ getValueAtPointer(input, ptr) ]\n                   = [ X(ptr.multi_dim_idx) ]\n                   = [ X(out_idx) ]。\n  3) 应用核函数：\n     Y(out_idx) = θ(input_scalars)\n                = θ([ X(out_idx) ])\n                = asinh(X(out_idx))。\n- 由此对任意有效 out_idx，输出元素即为输入对应位置元素的一元反双曲正弦变换。\n\n七、结论（核函数与映射函数的明确给出）\n- 核函数 θ（k = 1）：\n  输入：v ∈ List.Vector ℝ 1；\n  输出：θ(v) = asinh(v.get(0))，其中 asinh(x) = ln(x + sqrt(x^2 + 1))。\n- 依赖映射 τ：\n  输入：out_idx ∈ Index(n)，满足 validIndex(dims, out_idx)；\n  输出：τ(out_idx) = [ptr]，其中 ptr.tensor_idx = 0，ptr.multi_dim_idx = out_idx。\n- 输出维度：output_dims = dims。\n- 逐元素关系：对所有有效 out_idx，有 Y(out_idx) = asinh(X(out_idx))。\n\n八、类型约束与说明\n- ONNX 类型约束 T ∈ {float16, bfloat16, float, double} 在本形式化中用 ℝ 进行数学建模；数值从 T 到 ℝ 与从 ℝ 回到 T 的具体量化/舍入是实现层面的问题，不影响该算子可表示为上述 SIMD 结构的事实。\n\n因此，ONNX 的 Asinh 为一个标准的逐元素一元算子，可以按上述方式精确转换为给定的 SIMD 算子形式。
