### 形式化定义与推导步骤

#### 1. 基础定义

**定义 1.1 (张量 Tensor)**
- 张量 `T` 是一个多维数组，是标量、向量和矩阵向更高维度的推广。
- 一个 `n` 阶张量 `T` 是张量空间 `R^(d1 × d2 × ... × dn)` 中的一个元素。
- 符号表示: `T ∈ R^(d1 × d2 × ... × dn)`
- 其中 `R` 代表实数域，`d1, d2, ..., dn` 是张量在每个维度上的大小。

**定义 1.2 (函数 Function)**
- 一个函数 `f` 将一个输入张量 `x` 映射到一个输出张量 `y`。
- 假设输入张量 `x ∈ R^(da1 × ... × dam)`，输出张量 `y ∈ R^(db1 × ... × dbn)`。
- 符号表示: `f: R^(da1 × ... × dam) -> R^(db1 × ... × dbn)`

**定义 1.3 (标量与张量表示)**
- 使用粗体符号 (例如 `x`, `y`) 表示张量。
- 使用非粗体符号 (例如 `x`, `y`) 表示标量。
- 张量索引使用零基索引，例如向量 `v` 的第一个元素是 `v[0]`。

#### 2. SIMD 函数相关定义

**定义 2.1 (核函数 Kernel Function)**
- 核函数 `θ` 是一个接受 `k` 个标量输入并产生一个标量输出的函数。
- 符号表示: `θ: R^k -> R`

**定义 2.2 (依赖映射 Dependency Mapping)**
- 对于一个函数 `f(x) -> y`，其依赖映射 `τ` 将输出张量 `y` 的每个索引 `i` 映射到输入张量 `x` 的一个索引列表。
- 设 `y` 的阶数为 `n`，`x` 的阶数为 `m`，核函数 `θ` 的输入数量为 `k`。
- 依赖映射 `τ` 将一个 `n` 维整数向量 (`y` 的索引) 映射到一个包含 `k` 个 `m` 维整数向量的列表 (`x` 的索引列表)。
- 符号表示: `τ: N^n -> N^(k × m)`
- 其中 `idx(T)` 表示张量 `T` 的索引函数。

**定义 2.3 (SIMD 函数 SIMD Function)**
- 一个函数 `f(x) -> y` 如果满足以下条件，则被称为 SIMD 函数：
- 对于输出张量 `y` 中的任意索引 `i ∈ N^n`，其元素 `y[i]` 的计算方式如下：
  1.  `y[i] = θ(x_1, x_2, ..., x_k)`
      - 其中 `θ` 是 `f` 的核函数。
  2.  `x_j = x[τ(i)[j]]`，对于 `1 ≤ j ≤ k`
      - 其中 `τ` 是 `f` 的依赖映射。
- 综合表示: `y[i] = θ(x[τ(i)[0]], x[τ(i)[1]], ..., x[τ(i)[k-1]])`
- 为明确函数 `f` 与其核函数和依赖映射的关系，可记为 `y[i] = θ_f(x[τ_f(i)])`。

**定义 2.4 (线性依赖映射)**
- 在 LLM 算子中，依赖映射 `τ` 通常是仿射变换。
- 对于输出索引 `i`，其对应的输入索引列表可以表示为：
- `τ(i) = [M·i + b_1, M·i + b_2, ..., M·i + b_k]`
- 其中 `M` 是一个变换矩阵，`b_j` 是偏移向量。

#### 3. 其他函数与属性定义

**定义 3.1 (归约函数 Reductional Function)**
- 对于输入张量 `x ∈ R^m`，归约函数 `f_⊙` 应用一个二元操作 `⊙` 于 `x` 的所有元素。
- `f_⊙(x) = x[0] ⊙ x[1] ⊙ ... ⊙ x[m-1]`
- 该操作 `⊙` 必须满足交换律 (`a ⊙ b = b ⊙ a`) 和结合律 (`(a ⊙ b) ⊙ c = a ⊙ (b ⊙ c)`)。

**定义 3.2 (映射置换等价 Mapping Permutation Equivalence)**
- 对于两个依赖映射 `τ_1` 和 `τ_2`，如果存在一个置换函数 `P`，使得对于任意索引 `i`，都有 `P(τ_1(i)) = τ_2(i)`，则称 `τ_1` 和 `τ_2` 是映射置换等价的。
- 符号表示: `τ_1 ≃_P τ_2`

**定义 3.3 (核函数置换集等价 Kernel Permutation-set Equivalence)**
- 对于两个核函数 `θ_1` 和 `θ_2`，如果存在一个非空的置换函数集合 `Q`，使得对于集合中的任意置换 `P ∈ Q` 和任意输入 `x`，都有 `θ_1(x) = θ_2(P(x))`，则称 `θ_1` 和 `θ_2` 是核函数置换集等价的。
- 符号表示: `θ_1 ≃_Q θ_2`

**定义 3.4 (良构核函数 Well-formed Kernel Function)**
- 一个核函数 `θ` 被称为良构的，如果任意单个输入元素的改变都会导致输出的改变。
- 形式化地，存在输入 `x` 和 `x'`，如果 `x` 和 `x'` 仅在第 `i` 个位置不同 (`x[i] ≠ x'[i]` 且 `∀j ≠ i, x[j] = x'[j]`)，那么 `θ(x) ≠ θ(x')`。

**定义 3.5 (无重复输入索引)**
- 在实践中，对于任意输出索引 `i`，依赖映射 `τ(i)` 产生的输入索引列表 `[j_1, j_2, ..., j_k]` 中不包含重复的索引。
- 即 `∀a ≠ b`，有 `j_a ≠ j_b`。

#### 4. SMT 求解器的前提

**定义 4.1 (SMT 前提)**
- TrainVerify 使用 SMT 求解器在形状缩减的模型上验证等价性。如果求解器返回 `sat`，则对于所有输入 `x` 和特定的索引子集 `I`，以下等式成立：
- `f(x)[i] = g(x)[i]`, `∀x, ∀i ∈ I`
- 其中 `f` 是逻辑数据流图，`g` 是并行化后的数据流图。
- 索引子集 `I` 定义为：`I = { Σ_{j=0}^{n} a_j * e_j | a_j ∈ {0, 1} }`
- `e_j` 是标准基向量（第 `j` 个元素为 1，其余为 0），`e_0` 是零向量。该集合 `I` 包含了 `n` 维空间中所有由 `0` 和 `1` 组成的顶点。

#### 5. 主要证明

**引理 5.1 (依赖映射集等价性)**

**引理描述:**
对于两个良构的 SIMD 函数 `f` 和 `g` (定义 2.3, 3.4)，如果对于任意输入 `x`，它们在特定索引 `i` 上的输出都相等，那么它们在该索引 `i` 上的依赖映射 `τ_f(i)` 和 `τ_g(i)` 在集合上是等价的。即，它们包含完全相同的输入索引，只是顺序可能不同。

**前提:**
1. `f` 和 `g` 是良构的 SIMD 函数。
2. `∀x, f(x)[i] = g(x)[i]`

**结论:**
`set(τ_f(i)) = set(τ_g(i))`

**证明 (反证法):**
1.  根据 SIMD 函数定义 (2.3) 和前提 2，我们有：
    `∀x, θ_f(x[τ_f(i)]) = θ_g(x[τ_g(i)])`
2.  我们假设结论不成立，即 `set(τ_f(i)) ≠ set(τ_g(i))`。
3.  根据假设，必然存在一个索引 `j`，它属于其中一个集合而不属于另一个。不失一般性，我们假设：
    `j ∈ τ_f(i)` 且 `j ∉ τ_g(i)`。
4.  现在我们构造一个特殊的输入张量 `x'`：
    - `x'[j]` 为一个非零值 (例如 1)。
    - `x'` 的所有其他元素均为 0。
5.  我们将 `x'` 代入步骤 1 的等式中。
6.  计算等式右侧 `θ_g(x'[τ_g(i)])`：
    - 因为 `j ∉ τ_g(i)`，所以 `τ_g(i)` 列表中的所有索引 `k` 都满足 `k ≠ j`。
    - 因此，对于 `τ_g(i)` 中的所有索引，`x'[k]` 的值都为 0。
    - 所以，`x'[τ_g(i)]` 是一个全零的标量列表。
    - `θ_g(x'[τ_g(i)]) = θ_g(0, 0, ..., 0)`。
7.  计算等式左侧 `θ_f(x'[τ_f(i)])`：
    - 因为 `j ∈ τ_f(i)`，所以 `τ_f(i)` 列表中至少包含一个索引 `j`。
    - `x'[τ_f(i)]` 列表中的元素，对应于索引 `j` 的值为非零，其他值均为零。
    - 根据良构核函数定义 (3.4)，`θ_f` 的输出会因为这一个非零输入而改变。这意味着 `θ_f(x'[τ_f(i)]) ≠ θ_f(0, 0, ..., 0)`。
8.  现在我们面临一个矛盾：
    - 如果 `θ_f(0, ..., 0) ≠ θ_g(0, ..., 0)`，这与步骤 1 的前提 `∀x` 成立相矛盾 (我们可以选择一个全零的输入 `x`)。
    - 如果 `θ_f(0, ..., 0) = θ_g(0, ..., 0)`，那么步骤 6 和 7 的结果 `θ_f(x'[τ_f(i)]) ≠ θ_g(x'[τ_g(i)])` 与步骤 1 的前提 `∀x` 成立相矛盾。
9.  由于无论何种情况都存在矛盾，因此步骤 2 的假设不成立。
10. **证明完毕。** `set(τ_f(i)) = set(τ_g(i))` 成立。

---

**定理 5.2 (依赖映射的置换唯一性)**

**定理描述:**
对于两个良构的 SIMD 函数 `f` 和 `g`，如果对于任意输入 `x`，它们在特定索引 `i` 上的输出都相等，那么存在一个唯一的置换 `P`，使得 `τ_g(i)` 是 `τ_f(i)` 的一个置换。

**前提:**
1. `f` 和 `g` 是良构的 SIMD 函数。
2. `∀x, f(x)[i] = g(x)[i]`

**结论:**
`∃! P, P(τ_f(i)) = τ_g(i)`

**证明:**
1.  **存在性证明:**
    - 根据引理 5.1，我们已经证明 `set(τ_f(i)) = set(τ_g(i))`。
    - 这意味着 `τ_f(i)` 和 `τ_g(i)` 是包含相同元素但顺序可能不同的列表。
    - 根据置换的定义，必然存在至少一个置换函数 `P`，可以将 `τ_f(i)` 的元素重新排列，得到 `τ_g(i)`。
    - 存在性得证。
2.  **唯一性证明:**
    - 根据无重复输入索引的定义 (3.5)，`τ_f(i)` 列表中的所有索引都是唯一的。
    - 同样，`τ_g(i)` 列表中的所有索引也是唯一的。
    - 将一个没有重复元素的列表置换为另一个没有重复元素的列表，其置换方式是唯一的。
    - 唯一性得证。
3.  **证明完毕。**

---

**引理 5.3 (核函数置换等价性)**

**引理描述:**
对于两个良构的 SIMD 函数 `f` 和 `g`，如果它们在索引 `e_0` (零向量) 上的输出对于所有输入 `x` 都相等，那么它们的核函数 `θ_f` 和 `θ_g` 是置换集等价的。

**前提:**
1. `f` 和 `g` 是良构的 SIMD 函数。
2. `∀x, f(x)[e_0] = g(x)[e_0]`

**结论:**
`θ_f ≃_Q θ_g`

**证明:**
1.  根据前提 2 和 SIMD 函数定义 (2.3)，我们有：
    `∀x, θ_f(x[τ_f(e_0)]) = θ_g(x[τ_g(e_0)])`
2.  根据定理 5.2，从前提 2 可以推导出存在一个唯一的置换 `P_0`，使得 `P_0(τ_f(e_0)) = τ_g(e_0)`。
3.  将 `τ_g(e_0)` 替换到步骤 1 的等式中：
    `∀x, θ_f(x[τ_f(e_0)]) = θ_g(x[P_0(τ_f(e_0))])`
4.  根据张量索引的性质，对索引列表进行置换，等同于对索引结果的列表进行置换：
    `x[P_0(τ_f(e_0))] = P_0(x[τ_f(e_0)])`
5.  将步骤 4 代入步骤 3：
    `∀x, θ_f(x[τ_f(e_0)]) = θ_g(P_0(x[τ_f(e_0)]))`
6.  我们定义一个新的变量 `X = x[τ_f(e_0)]`。
    - 由于 `x` 是任意张量，并且根据定义 3.5，`τ_f(e_0)` 中的索引是唯一的，因此我们可以通过选择合适的 `x` 来让 `X` 取遍 `R^k` 中的任意向量。
7.  因此，步骤 5 的等式可以写成：
    `∀X ∈ R^k, θ_f(X) = θ_g(P_0(X))`
8.  根据核函数置换集等价的定义 (3.3)，这证明了 `θ_f` 和 `θ_g` 是置换集等价的，并且置换集 `Q` 至少包含 `P_0`。
9.  **证明完毕。**

---

**引理 5.5 (置换等价性)**

为了实现一个真正模块化且无逻辑跳跃的证明，我们将原证明分解为四个独立的子引理和一个主证明。

---

#### **置换理论背景**

**定义 5.5.1 (置换循环 Cycle of a Permutation)**
- 令 `S` 为一个有限集，`P` 是作用于 `S` 的一个置换。一个由不同元素 `j_1, j_2, ..., j_l` 组成的序列（其中 `l ≥ 1`）被称为一个长度为 `l` 的 **循环**，如果：
    - `P(j_1) = j_2`
    - `P(j_2) = j_3`
    - ...
    - `P(j_{l-1}) = j_l`
    - `P(j_l) = j_1`
- 并且对于 `S` 中所有不在此序列中的元素 `j`，都有 `P(j) = j`。
- 我们用 `(j_1, j_2, ..., j_l)` 来表示这个循环。

**定义 5.5.2 (不相交循环 Disjoint Cycles)**
- 两个或多个循环被称为 **不相交的**，如果它们不共享任何共同的元素。

**定理 5.5.3 (置换的循环分解 Cycle Decomposition Theorem)**
- 任何作用于有限集 `S` 的置换都可以被唯一地表示为一系列互不相交的循环的乘积（复合）。这是一个组合数学中的标准结论，我们在此直接引用。

---

#### **子引理**

**引理 5.5.A (共轭置换的恒定差分)**

**引理描述:**
给定引理 5.5 的前提，存在一个常量向量 `C` 和一个共轭置换 `P_conj = P_1^{-1} * P_0`，使得对于所有 `j ∈ {1, ..., k}`，以下等式成立：
`b_{f, P_conj(j)} - b_{f, j} = C`

**证明:**
1.  根据引理 5.5 的前提，我们有：
    - (A) `P_0([b_{f,1}, ..., b_{f,k}]) = [b_{g,1}, ..., b_{g,k}]`
    - (B) `P_1([M_f·e_1 + b_{f,1}, ..., M_f·e_1 + b_{f,k}]) = [M_g·e_1 + b_{g,1}, ..., M_g·e_1 + b_{g,k}]`
2.  从 (A) 可得 `b_{g,i} = b_{f, P_0^{-1}(i)}`。
3.  从 (B) 可得 `M_g·e_1 + b_{g,i} = M_f·e_1 + b_{f, P_1^{-1}(i)}`。
4.  将 (2) 代入 (3)：`M_g·e_1 + b_{f, P_0^{-1}(i)} = M_f·e_1 + b_{f, P_1^{-1}(i)}`。
5.  整理得：`b_{f, P_1^{-1}(i)} - b_{f, P_0^{-1}(i)} = (M_g - M_f) · e_1`。
6.  右侧与 `i` 无关，我们称之为常量向量 `C`。
7.  令 `j = P_0^{-1}(i)`，则 `i = P_0(j)`。代入上式：
    `b_{f, P_1^{-1}(P_0(j))} - b_{f, j} = C`
8.  定义共轭置换 `P_conj = P_1^{-1} * P_0`，引理得证。

---

**引理 5.5.B (非单位置换的非零差分)**

**引理描述:**
给定一个由 `k` 个互不相同的向量组成的列表 `B = [b_1, ..., b_k]` 和一个作用于索引 `{1, ..., k}` 的非单位置换 `P ≠ I`。如果存在一个常量 `C` 使得 `b_{P(j)} - b_j = C` 对所有 `j` 成立，那么 `C` 必然是一个非零向量。

**证明:**
1.  因为 `P` 不是单位置换 (`P ≠ I`)，所以至少存在一个索引 `j_0` 使得 `P(j_0) ≠ j_0`。
2.  根据前提，向量列表 `B` 中的所有向量都是互不相同的 (此性质由定义 3.5 和 `τ_f(e₀)` 的形式保证)。
3.  因此，`b_{P(j_0)}` 和 `b_{j_0}` 是两个不同的向量。
4.  所以它们的差 `b_{P(j_0)} - b_{j_0}` 是一个非零向量。
5.  由于这个差等于常量 `C`，故 `C ≠ 0`。引理得证。

---

**引理 5.5.C (循环差和为零)**

**引理描述:**
给定一个向量列表 `B` 和一个置换 `P`。如果存在常量 `C` 使得 `b_{P(j)} - b_j = C` 对所有 `j` 成立，并且 `P` 的循环分解中包含一个长度为 `l > 1` 的循环 `(j_1, j_2, ..., j_l)`，那么 `C` 必然是零向量。

**证明:**
1.  根据循环的定义，我们有 `P(j_1)=j_2`, `P(j_2)=j_3`, ..., `P(j_l)=j_1`。
2.  将前提 `b_{P(j)} - b_j = C` 应用于循环中的每个元素：
    - `b_{j_2} - b_{j_1} = C`
    - `b_{j_3} - b_{j_2} = C`
    - ...
    - `b_{j_1} - b_{j_l} = C`
3.  将这 `l` 个等式相加，左侧形成伸缩求和：
    `(b_{j_2} - b_{j_1}) + (b_{j_3} - b_{j_2}) + ... + (b_{j_1} - b_{j_l}) = l * C`
4.  左侧所有项相互抵消，结果为零向量 `0`。
5.  因此，`l * C = 0`。
6.  因为 `l > 1`，所以 `l` 是非零标量，故唯一的解是 `C = 0`。引理得证。

---

**引理 5.5.D (非单位置换的长循环存在性)**

**引理描述:**
任何作用于有限集 `S` 的非单位置换 `P ≠ I`，其根据 **定理 5.5.3** 做出的循环分解中，必然包含至少一个长度 `l > 1` 的循环。

**证明 (反证法):**
1.  **假设** `P` 的循环分解中不包含任何长度大于 1 的循环。
2.  这意味着 `P` 的所有循环的长度都为 1。
3.  根据 **定义 5.5.1 (置换循环)**，一个长度为 1 的循环 `(j₁)` 意味着 `P(j₁) = j₁`。
4.  如果所有循环长度均为 1，那么对于集合 `S` 中的每一个元素 `j`，都有 `P(j) = j`。
5.  这正是单位置换 `I` 的定义。所以 `P = I`。
6.  这与引理的前提 `P ≠ I` 相矛盾。
7.  因此，最初的假设错误。`P` 的循环分解中必须至少包含一个长度大于 1 的循环。**引理得证。**

---

**引理 5.5 (置换等价性) - 最终简化证明**

**前提:**
对于 `j ∈ {0, ..., n}`，存在唯一的置换 `P_j` 满足：
1. `P_0([b_{f,1}, ..., b_{f,k}]) = [b_{g,1}, ..., b_{g,k}]`
2. `P_j([M_f·e_j + b_{f,1}, ..., M_f·e_j + b_{f,k}]) = [M_g·e_j + b_{g,1}, ..., M_g·e_j + b_{g,k}]` (对于 `j > 0`)

**结论:**
`P_0 = P_1 = ... = P_n`

**证明 (反证法):**
1.  不失一般性，我们仅需证明 `P_1 = P_0`。
2.  **假设 `P_1 ≠ P_0`**。
3.  根据 **引理 5.5.A**，存在常量 `C` 和置换 `P_conj = P_1^{-1} * P_0`，使得 `b_{f, P_conj(j)} - b_{f, j} = C`。
4.  因为 `P_1 ≠ P_0`，所以 `P_conj` 是一个非单位置换 (`P_conj ≠ I`)。
5.  将 `P_conj` 应用于 **引理 5.5.B**，我们得出结论 **`C ≠ 0`**。
6.  同时，将 `P_conj` 应用于 **引理 5.5.D**，我们得知 `P_conj` 的循环分解中必然存在一个长度 `l > 1` 的循环。
7.  这个结论 (`存在 l > 1 的循环`) 满足了 **引理 5.5.C** 的前提。因此，应用引理 5.5.C，我们得出结论 **`C = 0`**。
8.  步骤 5 和步骤 7 的结论 (`C ≠ 0` 和 `C = 0`) 相互矛盾。
9.  这个矛盾源于步骤 2 的假设。因此，假设 `P_1 ≠ P_0` 必须是错误的。
10. **证明完毕。** `P_1 = P_0` 必须成立。同理可证所有 `P_j` 都相等。

---

**引理 5.4.A (线性依赖映射的参数关系)**

**引理描述:**
给定两个线性的依赖映射 `τ_f` 和 `τ_g`，如果存在一个统一的置换 `P`，使得对于所有标准基向量 `e_j` (`j ∈ {0, ..., n}`)，`τ_g(e_j)` 都是 `τ_f(e_j)` 的 `P` 置换，那么它们的变换矩阵 `M_f` 和 `M_g` 相等，并且它们的偏移向量列表 `b_f` 和 `b_g` 之间也存在 `P` 置换关系。

**前提:**
1. `τ_f(i) = [M_f·i + b_{f,1}, ..., M_f·i + b_{f,k}]`
2. `τ_g(i) = [M_g·i + b_{g,1}, ..., M_g·i + b_{g,k}]`
3. 存在一个置换 `P`，使得 `∀j ∈ {0, ..., n}, P(τ_f(e_j)) = τ_g(e_j)`。
4. `τ_f` 和 `τ_g` 满足无重复输入索引的性质 (定义 3.5)。

**结论:**
1. `M_f = M_g`
2. `P([b_{f,1}, ..., b_{f,k}]) = [b_{g,1}, ..., b_{g,k}]`

**证明:**
1.  **分析偏移向量 `b`**:
    - 当 `j=0` 时，`e_0` 是零向量，`M·e_0 = 0`。
    - 前提 3 简化为 `P(τ_f(e_0)) = τ_g(e_0)`，即 `P([b_{f,1}, ..., b_{f,k}]) = [b_{g,1}, ..., b_{g,k}]`。
    - 这证明了结论 2。
    - 根据置换的定义，这意味着对于任意 `l ∈ {1,...,k}`，都有 `b_{g,l} = b_{f, P^{-1}(l)}`。

2.  **分析变换矩阵 `M`**:
    - 现在考虑 `j > 0` 的情况。前提 3 给出 `P(τ_f(e_j)) = τ_g(e_j)`。
    - 展开这个列表等式，对于任意 `l ∈ {1,...,k}`，置换后列表的第 `l` 个元素等于原列表的第 `P^{-1}(l)` 个元素：
    - `(τ_g(e_j))_l = (τ_f(e_j))_{P^{-1}(l)}`
    - `M_g·e_j + b_{g,l} = M_f·e_j + b_{f, P^{-1}(l)}`
    - 将步骤 1 中得到的 `b_{g,l} = b_{f, P^{-1}(l)}` 关系代入此式：
    - `M_g·e_j + b_{f, P^{-1}(l)} = M_f·e_j + b_{f, P^{-1}(l)}`
    - 消去两边相同的 `b` 项，我们得到 `M_g·e_j = M_f·e_j`。
    - 这个结论对所有标准基向量 `e_j` (`j>0`) 都成立。
    - 由于 `M·e_j` 代表矩阵 `M` 的第 `j` 列，这意味着矩阵 `M_f` 和 `M_g` 的所有列都相等。
    - 因此，我们可以断定矩阵 `M_f = M_g`。这证明了结论 1。

3.  **证明完毕。**

---

**引理 5.4 (依赖映射置换等价性)**

**引理描述:**
对于两个良构的 SIMD 函数 `f` 和 `g`，如果它们在 SMT 前提所定义的索引子集 `I` 上的输出对于所有输入 `x` 都相等，那么它们的依赖映射 `τ_f` 和 `τ_g` 是映射置换等价的。

**前提:**
1. `f` 和 `g` 是良构的 SIMD 函数 (定义 2.3, 3.4)。
2. `f` 和 `g` 的依赖映射 `τ_f`, `τ_g` 均满足无重复输入索引的性质 (定义 3.5)。
3. `f` 和 `g` 的依赖映射 `τ_f`, `τ_g` 均是线性的 (仿射变换) (定义 2.4)。
4. `∀x, ∀i ∈ I, f(x)[i] = g(x)[i]` (其中 `I` 如定义 4.1 所示，包含了 `e_0, e_1, ..., e_n`)。

**结论:**
`τ_f ≃_P τ_g` (存在一个唯一的置换 `P` 使得 `∀i, P(τ_f(i)) = τ_g(i)`)。

**证明:**
1.  **前提实例化**: 根据前提 4，等式 `f(x)[i] = g(x)[i]` 对索引集 `I` 中的所有索引都成立。由于标准基向量 `e_j` (对于 `j ∈ {0, ..., n}`) 都在 `I` 中，我们可以得到 `n+1` 个具体实例：
    `∀j ∈ {0, ..., n}, ∀x, f(x)[e_j] = g(x)[e_j]`

2.  **应用置换唯一性定理**: 对于上述 `n+1` 个实例中的每一个，都满足 **定理 5.2 (依赖映射的置换唯一性)** 的前提。因此，对于每一个 `j ∈ {0, ..., n}`，都存在一个**唯一**的置换 `P_j`，使得：
    `P_j(τ_f(e_j)) = τ_g(e_j)`

3.  **证明所有置换 `P_j` 相等**:
    - 将前提 3 (线性依赖映射) 展开，上述等式构成了满足 **引理 5.5 (置换等价性)** 前提的方程组。
    - 应用引理 5.5，我们可以得出结论：所有从该方程组中导出的置换 `P_j` 都是相等的。
    - `P_0 = P_1 = ... = P_n`
    - 我们将这个对所有 `e_j` 都成立的唯一置换记为 `P`。

4.  **推导全局参数关系**:
    - 我们现在拥有一个对所有 `j ∈ {0, ..., n}` 都成立的统一置换 `P`。
    - 将 `P` 和线性依赖映射的展开式代入步骤 2 的等式中，这满足了 **引理 5.4.A (线性依赖映射的参数关系)** 的前提。
    - 应用引理 5.4.A，我们可以得出全局参数关系：
        - `M_f = M_g`
        - `P([b_{f,1}, ..., b_{f,k}]) = [b_{g,1}, ..., b_{g,k}]`

5.  **推广到任意索引**: 现在我们需要证明 `P(τ_f(i)) = τ_g(i)` 对于**任意**索引 `i ∈ N^n` 都成立。
    - `P(τ_f(i)) = P([M_f·i + b_{f,1}, ..., M_f·i + b_{f,k}])` (根据定义 2.4)
    - 根据置换的定义，置换后列表的第 `l` 个元素是原列表的第 `P^{-1}(l)` 个元素。
    - `P(τ_f(i))` 的第 `l` 个元素是 `M_f·i + b_{f, P^{-1}(l)}`。
    - 根据步骤 4 的参数关系，我们有 `M_f = M_g` 和 `b_{g,l} = b_{f, P^{-1}(l)}`。
    - 将其代入，得到 `M_g·i + b_{g,l}`。
    - 这正是 `τ_g(i)` 列表的第 `l` 个元素。
    - 由于 `l` 是任意的，所以 `P(τ_f(i)) = τ_g(i)`。

6.  **结论**: 我们已经证明了存在一个唯一的置换 `P`，使得对于任意索引 `i`，都有 `P(τ_f(i)) = τ_g(i)`。这完全符合 **定义 3.2 (映射置换等价)**。
7.  **证明完毕。** `τ_f ≃_P τ_g` 成立。

---

**定理 5.6 (形状缩减正确性定理)**

**定理描述:**
对于两个良构的 SIMD 函数 `f` 和 `g`，如果 SMT 求解器验证了它们在索引子集 `I` 上的输出等价性，那么这两个函数是完全等价的，即对于任何输入 `x` 和任何索引 `j`，它们的输出都相等。

**前提:**
1.  `f` 和 `g` 是良构的 SIMD 函数 (定义 2.3, 3.4)。
2.  `f` 和 `g` 的依赖映射 `τ_f`, `τ_g` 均满足无重复输入索引的性质 (定义 3.5)。
3.  `f` 和 `g` 的依赖映射 `τ_f`, `τ_g` 均是线性的 (仿射变换) (定义 2.4)。
4.  `∀x, ∀i ∈ I, f(x)[i] = g(x)[i]` (SMT 前提, 定义 4.1)。

**结论:**
`∀x, ∀j, f(x)[j] = g(x)[j]`

**证明:**

1.  **推导依赖映射的全局置换关系:**
    a.  前提 2 (`∀x, ∀i ∈ I, f(x)[i] = g(x)[i]`) 完全满足**引理 5.4**的条件。
    b.  应用**引理 5.4**，可得 `f` 和 `g` 的依赖映射是映射置换等价的。
    c.  根据映射置换等价的定义 (3.2)，这意味着存在一个**唯一的**置换 `P`，使得对于**任意**索引 `j`，都有 `P(τ_f(j)) = τ_g(j)`。

2.  **推导核函数的置换关系:**
    a.  根据定义 4.1，零向量索引 `e_0` 属于索引集 `I`。
    b.  因此，从前提 2 可具体化得到：`∀x, f(x)[e_0] = g(x)[e_0]`。
    c.  此结论完全满足**引理 5.3**的条件。
    d.  应用**引理 5.3**，可得 `f` 和 `g` 的核函数是置换集等价的 (`θ_f ≃_Q θ_g`)。
    e.  根据引理 5.3 的证明，置换集 `Q` 包含在索引 `e_0` 处的唯一置换 `P_0`。
    f.  由于在步骤 1c 中得出的置换 `P` 对于所有索引都是唯一的，因此必然有 `P = P_0`。
    g.  综合 e 和 f，可得 `P ∈ Q`。根据核函数置换集等价的定义 (3.3)，这意味着 `∀X ∈ R^k, θ_f(X) = θ_g(P(X))`。

3.  **引入辅助引理**
    a.  **引理 5.6.A (置换索引与置换值的等价性):** 对一个由张量索引 `τ` 得到的值列表 `x[τ]` 应用置换 `P`，其结果等价于先对索引列表 `τ` 应用置换 `P`，再用新的索引列表 `P(τ)` 从张量中取值。
    b.  **形式化表述:** `P(x[τ]) = x[P(τ)]`。
    c.  *此引理需在主证明之外单独证明，其证明依赖于置换和张量索引的具体定义。*

4.  **组合推导，证明完全等价性:**
    a.  我们的目标是证明对于任意输入 `x` 和任意索引 `j`，`f(x)[j] = g(x)[j]`。
    b.  `f(x)[j] = θ_f(x[τ_f(j)])`
        - (根据 SIMD 函数定义 2.3)
    c.  `... = θ_g(P(x[τ_f(j)]))`
        - (根据步骤 2g 的结论)
    d.  `... = θ_g(x[P(τ_f(j))])`
        - (应用**引理 5.6.A**)
    e.  `... = θ_g(x[τ_g(j)])`
        - (根据步骤 1c 的结论)
    f.  `... = g(x)[j]`
        - (根据 SIMD 函数定义 2.3)
    g.  通过以上等式链，我们证明了 `f(x)[j] = g(x)[j]`。由于 `x` 和 `j` 是任意的，定理得证。

**证明完毕。**

---

#### 6. 归约操作的正确性证明

**定理 6.1 (归约函数等价性扩展)**

**定理描述:**
给定两个归约函数 `f_⊙` 和 `g_⊕` (定义 3.1)，如果它们在大小为 2 的输入张量上的结果相等，那么它们在任何大小 `n ≥ 2` 的输入张量上的结果也都相等。这表明，对于满足交换律和结合律的归约操作，我们只需验证最小规模（两个元素）的等价性，即可将其推广到任意规模。

**前提:**
1.  `f_⊙` 和 `g_⊕` 是归约函数，其操作 `⊙` 和 `⊕` 满足交换律和结合律。
2.  `∀x ∈ R^2, f_⊙(x) = g_⊕(x)`。

**结论:**
`∀n ≥ 2, ∀x ∈ R^n, f_⊙(x) = g_⊕(x)`

**证明 (数学归纳法):**

1.  **基础步骤 (Base Case):**
    -   我们需要证明当 `n=2` 时结论成立。
    -   根据前提 2，`∀x ∈ R^2, f_⊙(x) = g_⊕(x)`。
    -   这直接满足了基础步骤的要求，因此基础情况成立。

2.  **归纳假设 (Inductive Hypothesis):**
    -   我们假设当输入张量大小为 `k` (其中 `k ≥ 2`) 时，结论成立。
    -   即，`∀x' ∈ R^k, f_⊙(x') = g_⊕(x')`。

3.  **归纳步骤 (Inductive Step):**
    -   我们需要证明当输入张量大小为 `k+1` 时，结论依然成立。
    -   令 `x` 是一个大小为 `k+1` 的张量，`x ∈ R^(k+1)`。
    -   我们可以将 `x` 视为一个大小为 `k` 的子张量 `x'` 和最后一个元素 `x[k]` 的组合，其中 `x' = [x[0], ..., x[k-1]]`。
    -   现在我们来计算 `f_⊙(x)`：
    -   `f_⊙(x) = (x[0] ⊙ ... ⊙ x[k-1]) ⊙ x[k]`
